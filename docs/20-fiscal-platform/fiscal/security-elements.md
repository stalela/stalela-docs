# Security Elements on Invoices

The DGI SFE specification and the Stalela architecture mandate that every fiscal event carries **five immutable security elements**. In Phase 1 (Software Invoicing), the **Cloud Signing Service (HSM)** owns the counters, identifiers, timestamps, and signatures that prove an invoice was issued by an authorized system. Client applications (web dashboard, API consumers, SDK integrators) must treat these values as sealed outputs — they may display them but never fabricate or modify them.

!!! warning "Cloud-generated security elements"
    Client applications MAY NOT fabricate any of these values. They are generated inside the Cloud Signing Service (HSM), travel only in sealed responses, and are recorded in the append-only Fiscal Ledger. Missing or modified elements invalidate the invoice.

!!! info "Phase 3 — USB Hardware"
    In Phase 3, the USB Fiscal Memory device (DEF) can replace or augment the Cloud Signing Service as the trusted signer for merchants who need full DEF homologation. The five elements remain identical; only the generation source changes. Hardware details are archived in `docs-archive/hardware/`.

## Sequential fiscal invoice number

- **What it is:** A monotonic, non-resettable counter that assigns every invoice a unique fiscal number and anchors the hash-chained Fiscal Ledger used for reports.
- **Generated by:** The Cloud Signing Service via the **Monotonic Counter Manager** (Online), or the **Fiscal Extension** (Offline Phase 1.5) strictly within its pre-allocated block of numbers.
- **Receipt placement:** Prominently printed near the merchant header so auditors see the outlet-level fiscal sequence.
- **Verification:** The dashboard, API consumers, and DGI compare the printed number with the Fiscal Ledger entry, the Z/X reports, and the expected counter for that outlet.
- **Missing / invalid:** The invoice is immediately rejected by the DGI and cannot be synchronized; the client must re-submit the canonical payload so the Cloud Signing Service can issue a new fiscal number.

## Fiscal authority ID

- **What it is:** A unique identifier for the Cloud Signing Service instance (or HSM cluster) that produced the fiscal response. In Phase 3, this maps to the DEF NID for USB-signed invoices.
- **Generated by:** Assigned during HSM provisioning; the Cloud Signing Service includes it in every sealed response alongside the fiscal number and signature.
- **Receipt placement:** Printed beside the fiscal number in the security block so inspectors can trace the signing authority.
- **Verification:** Auditors and the DGI cross-check the fiscal authority ID against the registered HSM public key in the Stalela Cloud registry.
- **Missing / invalid:** Without a fiscal authority ID, the invoice cannot be tied to a certified signing service, and the DGI must mark it non-compliant.

## Cryptographic authentication code (signature)

- **What it is:** An ECDSA signature over the canonical payload, fiscal number, timestamp, and ledger metadata that proves the Cloud Signing Service approved the invoice.
- **Generated by:** The HSM inside the Cloud Signing Service (Online), or the **Fiscal Extension** using a short-lived Delegated Credential (Offline Phase 1.5).
- **Receipt placement:** Included in the security block or encoded inside the QR code so scanning software can verify it.
- **Verification:** The DGI, auditors, and Stalela dashboard validate the signature using the HSM's public key from the registry; signatures that fail verification trigger rejection.
- **Missing / invalid:** If the signature is absent or fails verification, the invoice is treated as unauthenticated and cannot be lodged with the DGI; the client must re-submit the payload for re-signing.

## Trusted timestamp

- **What it is:** A UTC timestamp anchored to NTP-synced cloud infrastructure that records when the Cloud Signing Service sealed the invoice.
- **Generated by:** The Cloud Signing Service at the moment of signing (Online), or the Fiscal Extension's local clock (Offline Phase 1.5). During reconciliation, the Cloud verifies that the offline timestamp falls within the validity window of the Delegated Credential.
- **Receipt placement:** Shown near the fiscal number / authority ID block and embedded in the QR payload to prove when the invoice was sealed.
- **Verification:** The Fiscal Ledger enforces monotonic ordering per outlet; the DGI and auditors compare timestamps against ledger order to detect drift or replay.
- **Missing / invalid:** Invoices without a trusted timestamp are non-compliant, cannot be reconciled with Z/X reports, and raise alerts for potential tampering.

## QR code encoding verification data

- **What it is:** A machine-readable encoding of the fiscal number, fiscal authority ID, timestamp, signature, and a verification URL so inspectors and the DGI can validate the invoice.
- **Generated by:** The Cloud Signing Service (Online) or the Fiscal Extension (Offline Phase 1.5) after signing; the QR payload contains the sealed data that client applications render on receipts and the Sync Agent uploads to the DGI.
- **Receipt placement:** Typically printed at the bottom of the receipt, adjacent to the totals and security block.
- **Verification:** Inspectors and software scan the QR code to replay the data, validate the signature, and confirm the fiscal authority match. The QR encodes a URL to the **public verification portal** at `verify.stalela.cd` — see [Invoice Verification](invoice-verification.md) for the full verification flow, API, and cryptographic chain checks.
- **Missing / invalid:** Without the QR code the invoice fails the compliance checklist, and the DGI upload pipeline flags it as incomplete.

## Mock receipt layout

```mermaid
flowchart TB
  subgraph receipt["Mock receipt — Stalela fiscalized"]
    merchant["Merchant + outlet info"]
    fiscal["Fiscal number\nFiscal authority ID"]
    timestamp["Trusted timestamp"]
    signature["Cryptographic authentication code"]
    qr["QR code — verification payload"]
  end
  merchant --> fiscal --> timestamp --> signature --> qr
```

The diagram above shows how the five security elements are grouped near the receipt header and security block so every printout carries the data inspectors need. The QR code encapsulates the entire sealed payload, making verification a single scan away.

## Hash-chain integrity

Every entry in the Fiscal Ledger is hash-chained to its predecessor, creating a tamper-evident, append-only sequence that auditors and the DGI can verify independently.

### How it works

1. **Genesis entry:** The first invoice sealed for an outlet produces a ledger entry whose `previous_hash` is a well-known zero value (`0x00…00`). The Cloud Signing Service computes `entry_hash = SHA-256(fiscal_number ‖ canonical_payload_hash ‖ signature ‖ timestamp ‖ previous_hash)` and stores it alongside the sealed invoice.
2. **Subsequent entries:** Each new ledger entry includes the `entry_hash` of the immediately preceding entry as its `previous_hash`. The resulting chain means altering any past entry changes every hash that follows it.
3. **Scope:** Hash chains are maintained **per outlet** so each outlet has an independent, verifiable sequence aligned with its monotonic fiscal number counter.

### Ledger entry structure

| Field | Description |
|-------|-------------|
| `fiscal_number` | Sequential invoice number for the outlet |
| `canonical_payload_hash` | SHA-256 of the deterministic canonical payload |
| `signature` | ECDSA signature produced by the Cloud Signing Service (HSM) |
| `timestamp` | Trusted UTC timestamp at the moment of signing |
| `previous_hash` | `entry_hash` of the preceding ledger entry (`0x00…00` for the first) |
| `entry_hash` | SHA-256 of the concatenation of all fields above |

### Chain verification

```mermaid
flowchart LR
  A["Entry N-1\nentry_hash: abc123"] -->|previous_hash| B["Entry N\nentry_hash: def456"]
  B -->|previous_hash| C["Entry N+1\nentry_hash: ghi789"]
```

- **Online verification:** The [Invoice Verification](invoice-verification.md) API checks that the entry's `previous_hash` matches the preceding entry's `entry_hash` and recomputes the hash to confirm integrity.
- **Audit verification:** Z/X/A reports include the opening and closing `entry_hash` for the period. Auditors walk the chain between those anchors to confirm no entries were inserted, removed, or modified.
- **Tamper detection:** If any entry is altered, every subsequent `entry_hash` becomes invalid. The anomaly detection system flags hash-chain breaks as critical alerts.

### Immutability guarantees

- **Append-only:** The Fiscal Ledger never updates or deletes entries. Voids, refunds, and credit notes are new fiscal events with their own fiscal numbers and chain links.
- **Gap detection:** The Monotonic Counter Manager and hash chain together ensure that a missing fiscal number also breaks the chain, making gaps immediately detectable.
- **Cross-verification:** The DGI receives both the sealed invoice and the `entry_hash` via the Sync Agent, enabling independent chain reconstruction and verification on the regulatory side.

## Maintaining compliance

Client applications always send the canonical payload to the Cloud Signing Service, which returns the five sealed security elements. Even when a client is temporarily offline, it queues the unsigned payload locally (IndexedDB / SQLite) and submits it once connectivity returns — fiscalization only happens when the Cloud Signing Service processes the request. Missing elements, altered values, or attempts to generate them outside the Cloud Signing Service immediately invalidate the invoice and keep it out of the audit trail. If a submission fails (network timeout, validation error), the client retries the request so the Cloud Signing Service can issue all five elements together.
